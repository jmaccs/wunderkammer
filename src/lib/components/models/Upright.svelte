<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@2.0.3 static/models/upright.glb -s -T -k
-->

<script>
	import { Group } from 'three';
	import { T, forwardEventHandlers, watch } from '@threlte/core';
	import { useGltf, useCursor, interactivity } from '@threlte/extras';
	import * as THREE from 'three';
	import { spring } from 'svelte/motion';
	import { writable } from 'svelte/store';
	interactivity();
	export const ref = new Group();
	const gltf = useGltf('/models/upright-transformed.glb', { useDraco: true });
	const component = forwardEventHandlers();
	const { onPointerEnter, onPointerLeave } = useCursor();
	const white = new THREE.MeshStandardMaterial({ color: 'white' });
	const black = new THREE.MeshStandardMaterial({ color: 'black' });

	const keyRotations = {};
	let currentRotation = writable({});

	 function initKeySpring (keyName)  {
		keyRotations[keyName] =  spring(0, {
			stiffness: 0.1,
			damping: 0.4
		});
		keyRotations[keyName].subscribe((value) => {
			currentRotation.update((cr) => ({ ...cr, [keyName]: value }));
		});
	}

	function handlePointerDown(keyName) {
		if (keyRotations[keyName]) {
			keyRotations[keyName].set(0.1);
		}
	}

	function handlePointerUp(keyName) {
		if (keyRotations[keyName]) {
			keyRotations[keyName].set(0);
		}
	}

	function getKeyRotation(keyName) {
		let rotation = 0;
		keyRotations.update((rotations) => {
			if (rotations[keyName]) {
				rotation = rotations[keyName].get().x;
			}
			return rotations;
		});
		return rotation;
	}
	watch(currentRotation, ($currentRotation) => {
		return () => {
			console.log('cleanup');
		};
	});
</script>

<T
	is={ref}
	dispose={false}
	{...$$restProps}
	bind:this={$component}
	position={[10, 10, 0]}
	rotation.y={-Math.PI / 2}
	scale={1.4}
>
	{#await gltf}
		<slot name="fallback" />
	{:then gltf}
		<T.Group name="Scene">
			{#each Object.entries(gltf.nodes) as [nodeName, node]}
				{#if !nodeName.includes('Pedal') && !nodeName.includes('Upright') && node.geometry}
					<T.Mesh
						name={nodeName}
						castShadow
						receiveShadow
						geometry={node.geometry}
						material={nodeName.includes('#') ? black : white}
						position={[
							node.position?.x ?? 0,
							nodeName.includes('#') ? 0.63 : 0.59,
							nodeName.includes('#') ? -0.42 : -0.39
						]}
						rotation={[$currentRotation[nodeName] || 0, 0, 0]}
						on:create={() => {
							initKeySpring(nodeName);
						}}
						on:pointerenter={onPointerEnter}
						on:pointerleave={onPointerLeave}
						on:pointerdown={() => handlePointerDown(nodeName)}
						on:pointerup={() => handlePointerUp(nodeName)}
						on:pointerout={() => handlePointerUp(nodeName)}
					/>
				{/if}
			{/each}

			<T.Mesh
				name="Pedal_Baked"
				castShadow
				receiveShadow
				geometry={gltf.nodes.Pedal_Baked.geometry}
				material={gltf.materials.Pedal_Baked}
				position={[-0.97, -5.82, -1.55]}
				rotation={[0, -Math.PI / 2, 0]}
				scale={[0.36, 0.17, 0.36]}
			/>
			<T.Mesh
				name="Pedal_2_Baked"
				castShadow
				receiveShadow
				geometry={gltf.nodes.Pedal_2_Baked.geometry}
				material={gltf.materials['Pedal 2_Baked']}
				position={[0.1, -5.82, -1.56]}
				rotation={[0, -Math.PI / 2, 0]}
				scale={[0.36, 0.17, 0.36]}
			/>
			<T.Mesh
				name="Pedal_3_Baked"
				castShadow
				receiveShadow
				geometry={gltf.nodes.Pedal_3_Baked.geometry}
				material={gltf.materials['Pedal 3_Baked']}
				position={[1.02, -5.72, -1.45]}
				rotation={[0, -Math.PI / 2, 0]}
				scale={[0.36, 0.17, 0.36]}
			/>
			<T.Mesh
				name="Upright_Baked"
				castShadow
				receiveShadow
				geometry={gltf.nodes.Upright_Baked.geometry}
				material={gltf.materials.Upright_Baked}
			/>
		</T.Group>
	{:catch error}
		<slot name="error" {error} />
	{/await}
</T>
