<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@2.0.3 /Users/joemccarney/Documents/img/blender/wunderkammer/cabinet.glb -T -u -k
-->

<script>
	import * as THREE from 'three';
	import { T, forwardEventHandlers } from '@threlte/core';
	import { onMount, onDestroy, createEventDispatcher } from 'svelte';
	import { wunderkammerRef, screenActions, propValues, propActions } from '../utils/stores.js';
	import {
		useGltf,
		useGltfAnimations,
		useSuspense,
		useCursor,
		interactivity
	} from '@threlte/extras';
	interactivity();
	const { hovering, onPointerEnter, onPointerLeave } = useCursor();
	export const ref = new THREE.Group();

	const suspend = useSuspense();

	const gltf = suspend(useGltf('/models/cabinet-transformed.glb', { useDraco: true }));
	export const { actions, mixer } = useGltfAnimations(gltf, ref);

	$: doorsOpen = $propValues.wunderkammer.doorsOpen;
	export const triggerAnimation = () => {
		const cabinetActionL = $actions['Open Left'];
		const cabinetActionR = $actions['Open Right'];
		if (cabinetActionL && cabinetActionR) {
			cabinetActionL.loop = THREE.LoopOnce;
			cabinetActionR.loop = THREE.LoopOnce;
			cabinetActionL.clampWhenFinished = true;
			cabinetActionR.clampWhenFinished = true;
			if (doorsOpen) {
				propActions('wunderkammer', 'doorsOpen', true);
				cabinetActionL.timeScale = -cabinetActionL.timeScale;
				cabinetActionR.timeScale = -cabinetActionR.timeScale;
			} else if (!doorsOpen) {
				propActions('wunderkammer', 'doorsOpen', false);
				cabinetActionL.timeScale = cabinetActionL.timeScale;
				cabinetActionR.timeScale = cabinetActionR.timeScale;
			}
			cabinetActionL.paused = false;
			cabinetActionR.paused = false;
			cabinetActionR.play();
			cabinetActionL.play();
		}
	};

	onMount(() => {
		wunderkammerRef.set(ref);
	});
</script>

<T is={ref} dispose={false} {...$$restProps} scale={0.7} on:click={triggerAnimation}>
	{#await gltf}
		<slot name="fallback" />
	{:then gltf}
		<T.Mesh
			name="Cabinet_Baked"
			geometry={gltf.nodes.Cabinet_Baked.geometry}
			material={gltf.materials.Cabinet_Baked}
			castShadow
			receiveShadow
		/>
		<T.Mesh
			name="Door_L_Baked"
			geometry={gltf.nodes.Door_L_Baked.geometry}
			material={gltf.materials['Door L_Baked']}
			position={[-9.36, 18.45, 13.7]}
			castShadow
			receiveShadow
			on:pointerenter={onPointerEnter}
			on:pointerleave={onPointerLeave}
		/>
		<T.Mesh
			name="Door_R_Baked"
			geometry={gltf.nodes.Door_R_Baked.geometry}
			material={gltf.materials['Door R_Baked']}
			position={[8.89, 18.24, 14.07]}
			castShadow
			receiveShadow
			on:pointerenter={onPointerEnter}
			on:pointerleave={onPointerLeave}
		/>
	{:catch error}
		<slot name="error" {error} />
	{/await}

	<slot {ref} />
</T>
