<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@2.0.3 static/models/Burner.glb -s -T -k
-->

<script>
	import { Group, PointLight, PointLightHelper } from 'three';
	import { T, forwardEventHandlers, useTask } from '@threlte/core';
	import * as THREE from 'three';
	import { onDestroy, onMount } from 'svelte';
	import { useGltf, useTexture, TransformControls } from '@threlte/extras';
	import smokeVertex from './shaders/smoke/vertex.glsl?raw';
	import smokeFragment from './shaders/smoke/fragment.glsl?raw';
	let smoke;

	export const ref = new Group();

	const gltf = useGltf('/models/Burner-transformed.glb', { useDraco: true });

	const component = forwardEventHandlers();

	const smokeGeometry = new THREE.PlaneGeometry(1, 1, 16, 64);

	const perlinTexture = useTexture('/img/perlin.png', {
		tranform: (texture) => {
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set(4, 4);
			texture.minFilter = THREE.LinearFilter;
			texture.magFilter = THREE.LinearFilter;
			return texture;
		}
	});
	const smokeMaterial = new THREE.ShaderMaterial({
		uniforms: {
			uTime: { value: 0 },
			uPerlinTexture: { value: null }
		},
		vertexShader: smokeVertex,
		fragmentShader: smokeFragment,
		side: THREE.DoubleSide,
		transparent: true,
		depthWrite: false,
		blending: THREE.AdditiveBlending,
		toneMapped: true
	});

	onMount(() => {
		smokeGeometry.scale(10, 24, 10);

		perlinTexture.then((texture) => {
			smokeMaterial.uniforms.uPerlinTexture.value = texture;
		});
		smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
	});

	useTask((delta) => {
		smokeMaterial.uniforms.uTime.value += delta * 0.0005; // Slower animation
	});
</script>

<T is={ref} dispose={false} {...$$restProps} bind:this={$component}>
	{#await gltf}
		<slot name="fallback" />
	{:then gltf}
		<T.Mesh
			name="Cube003_Baked"
			castShadow
			receiveShadow
			geometry={gltf.nodes.Cube003_Baked.geometry}
			material={gltf.materials['Cube.003_Baked']}
			position={[1.2, 0.71, 0.29]}
		/>
		<T.Mesh
			name="Cube001_Baked"
			castShadow
			receiveShadow
			geometry={gltf.nodes.Cube001_Baked.geometry}
			material={gltf.materials['Cube.003_Baked']}
			position={[-1.06, 0.71, 0.29]}
		/>
		<T.Mesh
			name="Cube002_Baked"
			castShadow
			receiveShadow
			geometry={gltf.nodes.Cube002_Baked.geometry}
			material={gltf.materials['Cube.003_Baked']}
			position={[-0.07, 0.71, -1.43]}
			rotation={[Math.PI, 0, Math.PI]}
		/>
		<T.Mesh
			name="Body_Baked"
			castShadow
			receiveShadow
			geometry={gltf.nodes.Body_Baked.geometry}
			material={gltf.materials.Body_Baked}
			position={[0, 2.04, 0]}
		/>
		<T.Mesh
			name="Ash_Drawer_Baked"
			castShadow
			receiveShadow
			geometry={gltf.nodes.Ash_Drawer_Baked.geometry}
			material={gltf.materials['Ash Drawer_Baked']}
			position={[0, 2.04, -0.65]}
		/>
		<T.Mesh
			name="Cylinder_Baked"
			castShadow
			receiveShadow
			geometry={gltf.nodes.Cylinder_Baked.geometry}
			material={gltf.materials.Cylinder_Baked}
			position={[0, 4.73, -0.77]}
		/>
		<T.Mesh
			name="Handle_Baked"
			castShadow
			receiveShadow
			geometry={gltf.nodes.Handle_Baked.geometry}
			material={gltf.materials.Handle_Baked}
			position={[0, 2.04, -0.65]}
		/>
		<T.Mesh
			name="Top_Grate_Baked"
			castShadow
			receiveShadow
			geometry={gltf.nodes.Top_Grate_Baked.geometry}
			material={gltf.materials['Top Grate_Baked']}
			position={[0, 4.24, -0.04]}
		/>
		<T.Mesh
			name="Cube005_Baked"
			castShadow
			receiveShadow
			geometry={gltf.nodes.Cube005_Baked.geometry}
			material={gltf.materials['Cube.005_Baked']}
			position={[0.06, 2.3, -0.83]}
			rotation={[-0.88, -0.36, -1.83]}
			scale={0.14}
		/>

		{#if smoke}
			<T is={smoke} position={[0, 23, 0]} />
		{/if}
	{:catch error}
		<slot name="error" {error} />
	{/await}

	<slot {ref} />
</T>
